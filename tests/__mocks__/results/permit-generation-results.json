{
  "0x4007": {
    "comments": [
      {
        "content": "@whilefoo rfc on how we can deal with comment outputs. Perhaps we can have a standard recognized property on the output interface? Then the kernel can decide whether to pass it around or something. \r\n```ts\r\ninterface PluginOutput {\r\n  comment: string; // html comment\r\n  rewards: Rewards; // { \"whilefoo\": \"500\", \"token\": \"0x0\" } etc\r\n}\r\n```",
        "id": 2030164289,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 16.448,
          "words": {
            "result": 2.64,
            "wordCount": 47,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2030164289"
      },
      {
        "content": "I think you should fork from and overtake that second pull due to us being behind schedule",
        "id": 2033488255,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 7.552,
          "words": {
            "result": 1.11,
            "wordCount": 17,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2033488255"
      },
      {
        "content": "I think the most pure architecture would be that plugins can NOT inherit (write) authentication (only read if possible) of the kernel. As a consequence, no plugin should be able to post directly any issue. Ideally it should only be the kernel with a direct interface to issues. Plugins should just output comment HTML and the kernel can post it all in a single comment at the end of the webhook event invocation chain.\r\nCould be interesting to have a dedicated plugin to handle commenting, but because this seems like such an essential capability, I would more carefully consider the pros/cons of including this within the kernel. \r\n- On one hand, I really like the idea of making the kernel as pure and lean as possible\r\n- On the other hand there are practical considerations that if every plugin standard output interface includes `comment:` and then we don't have the `comment` capability available (the comment plugin is not included in the config) then why is this a standard output property required on every plugin?\r\nI'm not concerned about latency now. Besides we can port any plugin to Cloudflare Workers (or combine several inside a single Worker) when we are ready to fix latency issues. To be honest though, except for setting labels, I have no problem with latency (like with permit generation) so there's no need to overengineer yet. I also love the GitHub Actions logs being available for easy debugging, and the fact that they are super generous with the compute. \r\nGiven the entire conversation and all the considerations, I definitely think we should do option 3. \r\nThis separates concerns the best, which will allow our plugin ecosystem to grow the fastest.",
        "id": 2036355445,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "li": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 7,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 12
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 87.072,
          "words": {
            "result": 12.21,
            "wordCount": 285,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036355445"
      },
      {
        "content": "I know JSON makes things more complicated than it needs to be with serialization/transport. Then we have problems like this https://github.com/ubiquity-os/conversation-rewards/issues/18. If the comment property is ONLY meant to be used for GitHub comments, then transporting HTML only is the most sensible. Besides, there's no other metadata thats necessary within the `comment` property, which is the main point of sending a JSON object (it has multiple properties.) \r\nAs a somewhat side note: there should also not be any variables inside of the HTML. We could look it as like server-side-rendering (or in this case, plugin-side-rendering) handle producing the final HTML output and then output it as a single string of html entities. \r\nWe are currently using `mdast` in `@ubiquity-os/comment-incentives` to generate virtual DOMs. No `window` needed.\r\nIf we agree that this is considered as technical debt, and that we are accruing this so that we can get back on schedule, ok.",
        "id": 2036370459,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 4,
                "score": 1
              },
              "p": {
                "elementCount": 4,
                "score": 1
              }
            },
            "result": 9
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 59.776,
          "words": {
            "result": 7.43,
            "wordCount": 159,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036370459"
      },
      {
        "content": "Going back to my \"plugin-side-rendering\" mention, the data manipulation happens inside of the logic of the plugin. Then when the plugin is finally done with all of its compute, it emits a single string in the `comment` output property. This string is the final, rendered HTML. \r\nThe `comment` output is not intended to be consumed by other plugins. In most cases, the kernel will concatenate all the `comment` outputs from every plugin and post a single comment at the end. Plugins will consume the `metadata` property output which will include raw values to work with. I forget where I originally proposed this, but imagine something like:\r\n```typescript\r\ntype HtmlString = string;\r\ntype RequestedPermits = { username: string; amount: string; token: string; }[]\r\ninterface PluginOutput {\r\n   metadata: Record<string, any>;\r\n   comment: HtmlString;\r\n   rewards: RequestedPermits;\r\n}\r\n```",
        "id": 2036393020,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 5,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 47.904,
          "words": {
            "result": 6.22,
            "wordCount": 129,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036393020"
      },
      {
        "content": "The proposed `comment` output is intended for ease of composability for MOST situations, basically that the output from one plugin would just be appended to the final rendered comment. For simple plugin configurations (plugins not modifying the output results of others) this seems like straightforward architecture. \r\nHowever, as we know, there will be situations where a subsequent plugin will consider the results of a previous plugin, which means it would need to change the comment that is rendered. \r\nIn this situation the subsequent plugin should clobber the output of the previous plugin. It is now clear to be that this will be a new challenge to express to the kernel that it should ignore the comment output of a previous plugin. I suppose it would be straightforward in the metadata using the plugin ID i.e. `{ \"silences\": [\"ubiquity-os/conversation-rewards\"] }`.\r\nI think that comments should be handled from within the kernel. There should not be a separate comment plugin. Read my explanation [here](https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036355445). \r\n### Inputs\r\nFor completeness of my [previous comment](https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036393020):\r\n```typescript\r\ntype PluginId = string; // i.e. `ubiquity-os/conversation-rewards` `ubiquity-os/daemon-pricing`\r\ninterface PluginInput {\r\n   metadata: Record<PluginId, any>;\r\n   context: GitHubEventContext;\r\n}\r\n```\r\nNotice that we should not pass in the HTML of other plugins. Instead, just the metadata (\"computed\") values from the previous plugins.",
        "id": 2036433646,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 3,
                "score": 1
              },
              "h3": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 6,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 11
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 74.624,
          "words": {
            "result": 9.57,
            "wordCount": 214,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036433646"
      },
      {
        "content": "I understand your concern and I would need to put more thought into composability. Maybe the `comment` proposal is bad after all due to your point. It's only useful with simple plugins, but for more complex ones your point is valid. \r\nI need help to think through how any partner in the future can create new plugins that modify \r\n1. permit reward amounts \r\n2. XP reward amounts\r\nI don't like the idea of having a single monolithic rewards generation plugin that wraps all the ways possible to compute rewards (i.e. time estimation, comment rewards, review rewards etc)",
        "id": 2036516869,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 2,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 5,
                "score": 1
              }
            },
            "result": 8
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 47.776,
          "words": {
            "result": 4.93,
            "wordCount": 98,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036516869"
      },
      {
        "content": "I see, so you're suggesting that we must annotate each comment as well in order to properly handle the scoring at the end?\nOff hand I think there's:\n1. Specification \n2. Issue comment\n3. Pull request comment (a normal comment on a pull request, not related to posting a \"review\"\n4. Pull request review comment (associated with a \"review state\" I.e. approved, left comments, requested changes)\nI suppose we need a better naming convention for the pull related ones. They are considered as separate entities according to the GitHub api. They require different methods to obtain both types.",
        "id": 2053332029,
        "score": {
          "formatting": {
            "content": {
              "li": {
                "elementCount": 4,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 5
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 35.616,
          "words": {
            "result": 4.88,
            "wordCount": 97,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2053332029"
      },
      {
        "content": "Consider calling it \"contributor\" and \"collaborator\" as that is how it is presented on the GitHub APIs as I recall. \nAlso I think you forgot about the \"review comments\"",
        "id": 2055783331,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 9.6,
          "words": {
            "result": 1.75,
            "wordCount": 29,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2055783331"
      },
      {
        "content": "Nice code quality per usual",
        "id": 2007841578,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.092,
          "words": {
            "result": 0.39,
            "wordCount": 5,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#pullrequestreview-2007841578"
      },
      {
        "content": "\"Comment\" implication isn't clear to me",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENT]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENT]:",
        "id": 1569964797,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.456,
          "words": {
            "result": 0.52,
            "wordCount": 7,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1569964797"
      },
      {
        "content": "I've always been anti empty string for variable declarations. It's led to too many problems with other less experienced developers. I wish for a linter rule to flag these as a consequence. \nConsider initializing an empty array as a buffer and then joining it at the end.",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1569970517,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 11.644,
          "words": {
            "result": 2.73,
            "wordCount": 49,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1569970517"
      },
      {
        "content": "Our RPCs don't work anymore",
        "diffHunk": "@@ -0,0 +1,22 @@\n+// available tokens for payouts\n+export const PAYMENT_TOKEN_PER_NETWORK: Record<string, { rpc: string; token: string; symbol: string }> = {\n+  \"1\": {\n+    rpc: \"https://rpc-bot.ubq.fi/v1/mainnet\",",
        "id": 1569971792,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.288,
          "words": {
            "result": 0.46,
            "wordCount": 6,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1569971792"
      },
      {
        "content": "Yes consider changing them to verbs \n`ISSUER`\n`COMMENTED`\nI'm not 100% the best way to name all of them I have to look at the full list",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENT]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENT]:",
        "id": 1570133378,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 16.76,
          "words": {
            "result": 1.7,
            "wordCount": 28,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570133378"
      },
      {
        "content": "`[].join(\"\");` yields an empty string as well if there's nothing in the array.",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1570159594,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 10.632,
          "words": {
            "result": 0.94,
            "wordCount": 14,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570159594"
      },
      {
        "content": "Perhaps it will make the config more expressive if you add other properties?\nFor example \n```yml\nobserve:\n   views:\n      - ISSUE\n      - PULL\n   actors:\n      - ISSUER \n      - COLLABORATOR \n   actions: \n      - COMMENTED\n```",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENTED]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENTED]:\n       formattingMultiplier: 0\n       wordValue: 0\n-    - type: [ISSUE, COLLABORATOR]:\n+    - type: [ISSUE, COLLABORATOR, COMMENTED]:",
        "id": 1570588757,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 12.172,
          "words": {
            "result": 1.49,
            "wordCount": 24,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570588757"
      },
      {
        "content": "What is this @link syntax",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}",
        "id": 1570589892,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.092,
          "words": {
            "result": 0.39,
            "wordCount": 5,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570589892"
      },
      {
        "content": "Just noticed the bit wise operators 1337 code",
        "diffHunk": "@@ -73,12 +103,17 @@ export class IssueActivity {\n     self: GitHubPullRequest | GitHubIssue | null\n   ) {\n     let ret = 0;\n-    ret |= \"pull_request_review_id\" in comment ? CommentType.REVIEW : CommentType.ISSUE;\n+    ret |= \"pull_request_review_id\" in comment || \"draft\" in comment ? CommentType.REVIEW : CommentType.ISSUE;",
        "id": 1570591425,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.652,
          "words": {
            "result": 0.59,
            "wordCount": 8,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570591425"
      },
      {
        "content": "It might seem convoluted but I think that it condenses the logic to coerce everything into a string as expected. This is a suggestion to be proactive when we set up the empty string linter one day. \nFor example if you `push` any element into the array (compared to `+=`) when you join they should render as expected.  \n```js \n[ null, null ].join(\"\"); // \"\"\nnull += null; // 0 I think?\n```",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1570596007,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 4
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 25.744,
          "words": {
            "result": 3.48,
            "wordCount": 65,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570596007"
      },
      {
        "content": "I am aware of its purpose. I am proposing to make the config more expressive so that its more intuitive to work with.",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENTED]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENTED]:\n       formattingMultiplier: 0\n       wordValue: 0\n-    - type: [ISSUE, COLLABORATOR]:\n+    - type: [ISSUE, COLLABORATOR, COMMENTED]:",
        "id": 1573720820,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 8.032,
          "words": {
            "result": 1.44,
            "wordCount": 23,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573720820"
      },
      {
        "content": "Will you use array syntax?",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1573722731,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.092,
          "words": {
            "result": 0.39,
            "wordCount": 5,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573722731"
      },
      {
        "content": "This regex appears to convert repeating spaces i.e. `\"   \"` to a single space `\" \"` what is the purpose of this?",
        "diffHunk": "@@ -0,0 +1,216 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      body += result[key].evaluationCommentHtml;\n+    }\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">\n+              [ ${result.total} ${getPayoutConfigByNetworkId(program.opts().evmNetworkId).symbol} ]\n+            </a>\n+          </h3>\n+          <h6>\n+            @${username}\n+          </h6>\n+        </b>\n+      </summary>\n+      <h6>Contributions Overview</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>View</th>\n+            <th>Contribution</th>\n+            <th>Count</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createContributionRows()}\n+        </tbody>\n+      </table>\n+      <h6>Conversation Incentives</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>Comment</th>\n+            <th>Formatting</th>\n+            <th>Relevance</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createIncentiveRows()}\n+        </tbody>\n+      </table>\n+    </details>\n+    `\n+      .replace(/\\s+/g, \" \")",
        "id": 1573723262,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 15.416,
          "words": {
            "result": 1.22,
            "wordCount": 19,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573723262"
      },
      {
        "content": "This doesn't seem right. Network ID 1 is mainnet. The RPC clearly is for gnosis chain. Perhaps try and find a nice mainnet RPC?",
        "diffHunk": "@@ -0,0 +1,22 @@\n+// available tokens for payouts\n+export const PAYMENT_TOKEN_PER_NETWORK: Record<string, { rpc: string; token: string; symbol: string }> = {\n+  \"1\": {\n+    rpc: \"https://rpc.gnosischain.com\",\n+    token: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n+    symbol: \"DAI\",\n+  },",
        "id": 1573723774,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 8.312,
          "words": {
            "result": 1.54,
            "wordCount": 25,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573723774"
      },
      {
        "content": "Seems like not a very useful mock.",
        "diffHunk": "",
        "id": 1573724498,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.456,
          "words": {
            "result": 0.52,
            "wordCount": 7,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573724498"
      },
      {
        "content": "Same here",
        "diffHunk": "",
        "id": 1573724853,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 4.504,
          "words": {
            "result": 0.18,
            "wordCount": 2,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573724853"
      },
      {
        "content": "The token address indeed represents DAI on mainnet.",
        "diffHunk": "@@ -0,0 +1,22 @@\n+// available tokens for payouts\n+export const PAYMENT_TOKEN_PER_NETWORK: Record<string, { rpc: string; token: string; symbol: string }> = {\n+  \"1\": {\n+    rpc: \"https://rpc.gnosischain.com\",\n+    token: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n+    symbol: \"DAI\",\n+  },",
        "id": 1574086028,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.652,
          "words": {
            "result": 0.59,
            "wordCount": 8,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574086028"
      },
      {
        "content": "@gentlementlegen rfc",
        "diffHunk": "@@ -0,0 +1,216 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      body += result[key].evaluationCommentHtml;\n+    }\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">\n+              [ ${result.total} ${getPayoutConfigByNetworkId(program.opts().evmNetworkId).symbol} ]\n+            </a>\n+          </h3>\n+          <h6>\n+            @${username}\n+          </h6>\n+        </b>\n+      </summary>\n+      <h6>Contributions Overview</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>View</th>\n+            <th>Contribution</th>\n+            <th>Count</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createContributionRows()}\n+        </tbody>\n+      </table>\n+      <h6>Conversation Incentives</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>Comment</th>\n+            <th>Formatting</th>\n+            <th>Relevance</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createIncentiveRows()}\n+        </tbody>\n+      </table>\n+    </details>\n+    `\n+      .replace(/\\s+/g, \" \")",
        "id": 1574086293,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 4.504,
          "words": {
            "result": 0.18,
            "wordCount": 2,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574086293"
      },
      {
        "content": "Why not do it in the industry standard way? All values are denominated in `1e18` without floating point. \nAt the end, for rendering, we just need to divide by `1e18`",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1575555444,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 17.04,
          "words": {
            "result": 1.8,
            "wordCount": 30,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1575555444"
      },
      {
        "content": "I'm not sure if I understand but task reward is if you completed the task (if you are an assignee when the issue is completed) and specification reward is if you write the specification (you are the original issue author)",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1575556553,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 10.58,
          "words": {
            "result": 2.35,
            "wordCount": 41,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1575556553"
      },
      {
        "content": "Spoke a bit on this in dms. @whilefoo my intent with referring to GitHub Issues as \"tasks\" was to emphasize that its a funded, and recognized \"real project\" so I want to refer to them as \"tasks\" instead of just \"issues.\"\r\nSince we are dealing so heavily with the GitHub API, I figured that there is benefit to being specific about what words we are using. Sure we can load in all the GitHub issues on a repository, but not all of them will be funded and recognized. \r\nWe are only primarily concerned with working with \"tasks\" aka funded GitHub issues.",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1576666170,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 26.14,
          "words": {
            "result": 5.05,
            "wordCount": 101,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1576666170"
      },
      {
        "content": "Possibly. I personally haven't had that issue but either way my suggestion is to keep everything internally without a decimal and then only convert it upon rendering.",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1577225638,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 8.76,
          "words": {
            "result": 1.7,
            "wordCount": 28,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1577225638"
      },
      {
        "content": "I think it's fine. I generally scrutinize test code less than normal program code anyways.",
        "id": 2063712447,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.7,
          "reward": 6.968,
          "words": {
            "result": 1.06,
            "wordCount": 16,
            "wordValue": 0.1
          }
        },
        "type": "PULL_COLLABORATOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#issuecomment-2063712447"
      }
    ],
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOiI2MTYzNTYwMDAwMDAwMDAwMDAwMDAifSwibm9uY2UiOiIzMzkyOTQxNzYyNzkzOTc1NTkzMTc4MTExNTY1OTgzNzk3NDc1ODk0MDM3NDk1NDA0MTMxMjg2MzgyNzgwNDExNjg3NzA4MzUyODg4IiwiZGVhZGxpbmUiOiIxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMxMjk2Mzk5MzUifSwidHJhbnNmZXJEZXRhaWxzIjp7InRvIjoiMHg0RDA3MDRmNDAwRDU3QmE5M2VFYTg4NzY1QzNGY0RCRDgyNmRDRmM0IiwicmVxdWVzdGVkQW1vdW50IjoiNjE2MzU2MDAwMDAwMDAwMDAwMDAwIn0sIm93bmVyIjoiMHhkOTUzMEYzZmJCRWExMWJlRDAxREMwOUU3OTMxOGYyZjIwMjIzNzE2Iiwic2lnbmF0dXJlIjoiMHg1MzMyODgxNjMzMjk4OWQzY2RiYTY4MjllOWRhMDcwOWU3MDU2OWMzNmRlZWFhNDc1NTY2ODQzZTBlZjY0ODc2MTgwMWQwYmMyY2I0MGI1YjdkNTc3NDc5NzY5MjRlNzgzNDgxODE2NTJlMmUzNjFlNTRiMTVmYTBhYTcwYjAwNTFiIiwibmV0d29ya0lkIjoxMDB9XQ==",
    "total": 616.356,
    "userId": 4975670
  },
  "gentlementlegen": {
    "comments": [
      {
        "content": "This needs https://github.com/ubiquity-os/conversation-rewards/pull/7 to be merged first. Also probably needs https://github.com/ubiquity-os/permit-generation/pull/2 to be able to generate the permits properly.",
        "id": 2033404518,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 19.104,
          "words": {
            "result": 2.22,
            "wordCount": 17,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2033404518"
      },
      {
        "content": "To me 1 is the most straightforward to do for few reasons:\r\n- the comment reward plugin has all the needed data already\r\n- it can import the https://github.com/ubiquity-os/permit-generation to generate permits itself\r\n- if it is done this way it can be used as a complete standalone without the kernel\r\n3 might make more sense in terms of architecture however. In such case the kernel should pass down results. It is more of an architecture question. Although, if we ever have other plugins in the flow that have influence on the total incentives, it would make sense to go through the kernel to aggregate the total result.",
        "id": 2036174312,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 5,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 10
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 73.152,
          "words": {
            "result": 10.36,
            "wordCount": 104,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036174312"
      },
      {
        "content": "I think each plugin should output JSON not html as it is not reliable to parse nor manipulate and requires `window` instance to be instantiated which is annoying on `node` based projects. \r\nHaving a plugin handling commenting seems quite weird as commenting is done by calling Octokit and the REST api which is already a library by itself, so no need to encapsulate it within another one to do the same thing.\r\nMy view on this, is to finalize https://github.com/ubiquity-os/permit-generation/issues/5 to import it withing the `conversation-reward` that will post the comment itself as well, otherwise the architecture will be quite convoluted doing ping pong with everything.",
        "id": 2036367126,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 61.696,
          "words": {
            "result": 10.53,
            "wordCount": 106,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036367126"
      },
      {
        "content": "If you want to manipulate and convey data, HTML really is not made for this. If you want something formatted similarly but made for data we can use XML format.\r\nThe new comment reward actually does instantiate a DOM through [JSDOM](https://github.com/ubiquity-os/conversation-rewards/blob/ba434761281446a23566cd02c68bd3b0e79d4eb1/src/parser/formatting-evaluator-module.ts#L80) to make things way simpler instead of using Regex everywhere which is highly unreliable. But there it makes sense because we are parsing comments from an HTML page content.\r\nBiggest advantage from this is to have the comment reward fully standalone, while easy to integrate with the kernel.\r\nIf we do something that handles the comment it means each and every module has to send it there and that module should understand every different content / format we send which would be way easier if the module itself handled its own comments, formatting wise.",
        "id": 2036385985,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 4,
                "score": 1
              }
            },
            "result": 5
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 61.12,
          "words": {
            "result": 12.85,
            "wordCount": 134,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036385985"
      },
      {
        "content": "But then how do we consider the formatting of that output?\r\nPractical case: we want to post a comment when a user queries a wallet. That comment is 'user name': 'wallet 0x0'\r\nKernel calls the comment plugin, saying that it wants a comment to be posted. Should the Kernel send the rendering it wants, should the comment plugin transform the data to HTML?\r\nThen, comment-reward wants to post the results. Should ask the Kernel to call the comment plugin, but then formatting is different. Should the Kernel notify the comment plugin that it wants a different output formatting? Should the Kernel compute beforehand the HTML and send it to the comment plugin?\r\nMight be something I don't grasp there. Because I do understand your use case but it seems to be very deterministic on what is the purpose of the plugins which kinda defeats the purpose of having plugins, looks more like a monolithic approach to me",
        "id": 2036411811,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 5,
                "score": 1
              }
            },
            "result": 5
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 67.584,
          "words": {
            "result": 14.87,
            "wordCount": 159,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036411811"
      },
      {
        "content": "This can work, but we skyrocket coupling and to me defeat purpose of plugins that should be unaware of each other. If any plugin has to understand the result of a previous plugin, it means these plugins have necessarily to co-exist so basically they become a single plugin with no purpose to split them.",
        "id": 2036458775,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 23.296,
          "words": {
            "result": 6.03,
            "wordCount": 55,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036458775"
      },
      {
        "content": "@pavlovcik To mitigate that that's why inside the comment reward itself I also integrated that `Module` principle so code is not coupled tightly and easy to build on. There is as usual pros and cons to both approaches (splitting or not) but biggest pro is that comments get evaluated once in the same spot, so we save calls to OpenAPI and speed up the process. Also makes it only one configuration file in one location. We need to think about our best options there.",
        "id": 2036535332,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 35.936,
          "words": {
            "result": 8.73,
            "wordCount": 85,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036535332"
      },
      {
        "content": "I realized that to carry this task properly we need to handle flags for comment more delicately as they only indicate if the comment is `ISSUE | REVIEW` with the level `MEMBER | CONTRIBUTOR` etc. but doesn't specify if it is from a task, a specification and so on. Tags should be added to the config properly as well.",
        "id": 2051094255,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 32.192,
          "words": {
            "result": 6.31,
            "wordCount": 58,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2051094255"
      },
      {
        "content": "Agreed, I think currently there are 3 possible things to annotate on the comments:\r\n- `SPECIFICATION` for the issue itself, `TASK` for the related PR fixing it, or simply `COMMENT`\r\n- `MEMBER` or `CONTRIBUTOR` for the status of the member\r\n- `REVIEW` or `ISSUE` for where the comment was added\r\nI think this shall cover all cases.",
        "id": 2054424028,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 7,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 5,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 16
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 0.8,
          "reward": 83.008,
          "words": {
            "result": 5.94,
            "wordCount": 54,
            "wordValue": 0.2
          }
        },
        "type": "ISSUE_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2054424028"
      },
      {
        "content": "In the v1 of the Ubiquibot, when a result gets evaluated, a recap is posted to the related issue with a summary and details of the rewards as well as the link to the rewards themselves Example: https://github.com/ubiquity/cloudflare-deploy-action/issues/9#issuecomment-2028623754\r\nThe same logic should be applied in the v2 version by creating a new Module responsible to post that comment. This module will receive a similar input than the one mentioned [here](https://github.com/ubiquity/cloudflare-deploy-action/issues/9#issuecomment-2028623754)\r\nThe module should be:\r\n- possible to enable / disable\r\n- eventually configurable (what data to show / hide)\r\n- coming with tests",
        "id": 2218638141,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 6,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 11
          },
          "multiplier": 1,
          "priority": 4,
          "relevance": 1,
          "reward": 61.8,
          "words": {
            "result": 4.45,
            "wordCount": 87,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_SPECIFICATION",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5"
      },
      {
        "content": "Resolves #5 \r\nDepends on #8 \r\nReviews looks gigantic but it's only due to the API snapshots I promise.",
        "id": 1822452078,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 0,
          "priority": 4,
          "relevance": 0.7,
          "reward": 0,
          "words": {
            "result": 0,
            "wordCount": 19,
            "wordValue": 0
          }
        },
        "type": "PULL_SPECIFICATION",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12"
      },
      {
        "content": "I think in this case it makes sense because this function will return `\"\"` if nothing is found. If I return `undefined` or `null` it will be interpreted in HTML as a string and will display the text null or undefined.\r\nI changed the code to always return `content` so it forces it to be properly initialized which should avoid mistakes.",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1570010044,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 4,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 6
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 84.344,
          "words": {
            "result": 6.49,
            "wordCount": 60,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570010044"
      },
      {
        "content": "It is supposed to represent a comment. Would you prefer a descriptive action such as `COMMENTED`?",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENT]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENT]:",
        "id": 1570011467,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 27.816,
          "words": {
            "result": 2.11,
            "wordCount": 16,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570011467"
      },
      {
        "content": "True, just picked this up from the previous codebase. https://rpc.gnosischain.com should do it for both then?",
        "diffHunk": "@@ -0,0 +1,22 @@\n+// available tokens for payouts\n+export const PAYMENT_TOKEN_PER_NETWORK: Record<string, { rpc: string; token: string; symbol: string }> = {\n+  \"1\": {\n+    rpc: \"https://rpc-bot.ubq.fi/v1/mainnet\",",
        "id": 1570014142,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 27.2,
          "words": {
            "result": 2,
            "wordCount": 15,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570014142"
      },
      {
        "content": "Seems convoluted to me and I don't know what problem that solved, but sure can do. Because either way this will yield an empty string or populated string?\r\nEither way changed to a `const string[]` to minimize mistakes then!",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1570187141,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 49.76,
          "words": {
            "result": 4.6,
            "wordCount": 40,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570187141"
      },
      {
        "content": "Changed `COMMENT` to `COMMENTED`, added jsdoc description for each value\r\nhttps://github.com/ubiquity-os/conversation-rewards/blob/559c13c9a7d548519a6434e1b8393fd0d5c8f3db/src/issue-activity.ts#L21",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENT]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENT]:",
        "id": 1570188450,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 5
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 47.952,
          "words": {
            "result": 1.42,
            "wordCount": 10,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1570188450"
      },
      {
        "content": "Simply makes the docs linking the code within the comment, for convenience, and looks like this\r\n<img width=\"598\" alt=\"image\" src=\"https://github.com/ubiquity-os/conversation-rewards/assets/9807008/76a60610-f3e4-4886-a9bd-c34a4c67a198\">\r\nAlso be careful you linked a random GitHub account within your comment",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}",
        "id": 1573413974,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 54.456,
          "words": {
            "result": 4.01,
            "wordCount": 34,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573413974"
      },
      {
        "content": "In the case of a string it would coerce the value and you would get \"null\" as a string so I get your point indeed",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1573416633,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 25.304,
          "words": {
            "result": 3.09,
            "wordCount": 25,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573416633"
      },
      {
        "content": "`observe` would help to chose what we want to include and ignore? We surely can add more properties as it goes. The purpose of this section is to attribute different multipliers based on the type of comment, mimicking the old [codebase](https://github.com/ubiquity-os/comment-incentives/blob/525fcdccc8f0d9032a41cdaed3b4fbc6514d44b6/src/handlers/issue/comment-scoring-by-contribution-style.ts)",
        "diffHunk": "@@ -27,29 +27,39 @@ formattingEvaluator:\n     td: 1\n     hr: 0\n   multipliers:\n-    - type: [ISSUE, ISSUER]:\n+    - type: [ISSUE, ISSUER, TASK]:\n+      formattingMultiplier: 1\n+      wordValue: 0.1\n+    - type: [ISSUE, ISSUER, COMMENTED]:\n       formattingMultiplier: 1\n       wordValue: 0.2\n-    - type: [ISSUE, ASSIGNEE]:\n+    - type: [ISSUE, ASSIGNEE, COMMENTED]:\n       formattingMultiplier: 0\n       wordValue: 0\n-    - type: [ISSUE, COLLABORATOR]:\n+    - type: [ISSUE, COLLABORATOR, COMMENTED]:",
        "id": 1573420718,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 50.32,
          "words": {
            "result": 4.7,
            "wordCount": 41,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573420718"
      },
      {
        "content": "Not very useful indeed. I am working on the tests on a separate PR to avoid cluttering that one. I didn't cover all the tests cases yet!\r\nhttps://github.com/ubiquity-os/conversation-rewards/pull/14",
        "diffHunk": "",
        "id": 1573731420,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 43.04,
          "words": {
            "result": 3.4,
            "wordCount": 28,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573731420"
      },
      {
        "content": "See https://github.com/ubiquity-os/conversation-rewards/pull/14 for the soon up to date mocks",
        "diffHunk": "",
        "id": 1573731649,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 22.552,
          "words": {
            "result": 1.17,
            "wordCount": 8,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573731649"
      },
      {
        "content": "Good point, also symbol should not be DAI but ETH isn't it?\r\n`pay.ubq.fi` seems to be using https://rpc.mevblocker.io for its RPC which seems to have low latency, a good privacy and score according to Chainlist as well.",
        "diffHunk": "@@ -0,0 +1,22 @@\n+// available tokens for payouts\n+export const PAYMENT_TOKEN_PER_NETWORK: Record<string, { rpc: string; token: string; symbol: string }> = {\n+  \"1\": {\n+    rpc: \"https://rpc.gnosischain.com\",\n+    token: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n+    symbol: \"DAI\",\n+  },",
        "id": 1573733603,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 57.2,
          "words": {
            "result": 4.5,
            "wordCount": 39,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573733603"
      },
      {
        "content": "Had changed it everywhere else but here, now it should be fine",
        "diffHunk": "@@ -0,0 +1,212 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";",
        "id": 1573737049,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 17.24,
          "words": {
            "result": 1.65,
            "wordCount": 12,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1573737049"
      },
      {
        "content": "This matches any whitespace character (spaces, tabs, line breaks) so basically I make the produced HTML one liner. This helps to collect it from the CLI, makes the string shorter and more compact.",
        "diffHunk": "@@ -0,0 +1,216 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    let body = \"\";\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      body += result[key].evaluationCommentHtml;\n+    }\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">\n+              [ ${result.total} ${getPayoutConfigByNetworkId(program.opts().evmNetworkId).symbol} ]\n+            </a>\n+          </h3>\n+          <h6>\n+            @${username}\n+          </h6>\n+        </b>\n+      </summary>\n+      <h6>Contributions Overview</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>View</th>\n+            <th>Contribution</th>\n+            <th>Count</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createContributionRows()}\n+        </tbody>\n+      </table>\n+      <h6>Conversation Incentives</h6>\n+      <table>\n+        <thead>\n+          <tr>\n+            <th>Comment</th>\n+            <th>Formatting</th>\n+            <th>Relevance</th>\n+            <th>Reward</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          ${createIncentiveRows()}\n+        </tbody>\n+      </table>\n+    </details>\n+    `\n+      .replace(/\\s+/g, \" \")",
        "id": 1574114225,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 29.896,
          "words": {
            "result": 3.91,
            "wordCount": 33,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574114225"
      },
      {
        "content": "By definition `dump` was just outputting results to stdout, but I could make it return the result as well. Since the console log is what we want to make sure works properly to be reused by other workflows, I thought it would make sense to test it that way because potentially if we forget other logs somewhere that would mess up the output for the next Action step.",
        "diffHunk": "@@ -0,0 +1,41 @@\n+import { parseGitHubUrl } from \"../src/start\";\n+import { IssueActivity } from \"../src/issue-activity\";\n+import { Processor } from \"../src/parser/processor\";\n+import { UserExtractorModule } from \"../src/parser/user-extractor-module\";\n+import { server } from \"./__mocks__/node\";\n+import { DataPurgeModule } from \"../src/parser/data-purge-module\";\n+import userCommentResults from \"./__mocks__/results/user-comment-results.json\";\n+import dataPurgeResults from \"./__mocks__/results/data-purge-result.json\";\n+\n+const issueUrl = process.env.TEST_ISSUE_URL || \"https://github.com/ubiquity-os/comment-incentives/issues/22\";\n+\n+beforeAll(() => server.listen());\n+afterEach(() => server.resetHandlers());\n+afterAll(() => server.close());\n+\n+describe(\"Modules tests\", () => {\n+  const issue = parseGitHubUrl(issueUrl);\n+  const activity = new IssueActivity(issue);\n+\n+  beforeAll(async () => {\n+    await activity.init();\n+  });\n+\n+  it(\"Should extract users from comments\", async () => {\n+    const logSpy = jest.spyOn(console, \"log\");\n+    const processor = new Processor();\n+    processor[\"_transformers\"] = [new UserExtractorModule()];\n+    await processor.run(activity);\n+    processor.dump();\n+    expect(logSpy).toHaveBeenCalledWith(JSON.stringify(userCommentResults, undefined, 2));",
        "id": 1574622869,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 56.432,
          "words": {
            "result": 7.22,
            "wordCount": 68,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574622869"
      },
      {
        "content": "Un-nested them one level. I think that the `buildXrow` should just be contained by that function because its purpose only serves inside of it.",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(",
        "id": 1574702577,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 33.304,
          "words": {
            "result": 3.09,
            "wordCount": 25,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574702577"
      },
      {
        "content": "I assumed BigInt only handles integers, and we manipulate a lot of floating decimal values for our operations (mostly everything has a floating point)",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1574724902,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 24.688,
          "words": {
            "result": 2.98,
            "wordCount": 24,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574724902"
      },
      {
        "content": "There is one permit generated per participating user, last run:\r\nhttps://github.com/Meniole/test/issues/1#issuecomment-2069443938",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">",
        "id": 1574767984,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 31.952,
          "words": {
            "result": 1.42,
            "wordCount": 10,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574767984"
      },
      {
        "content": "I made it according to the previous version:\r\n- Issue Specification means the item when opening an issue\r\n- Issue Task means the item that fixed the issue\r\nExample with the current comments:\r\nhttps://github.com/ubiquity-os/comment-incentives/issues/31#issuecomment-1998609326",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1575659438,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 5,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 9
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 92.72,
          "words": {
            "result": 3.7,
            "wordCount": 31,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1575659438"
      },
      {
        "content": "Wouldn't that lead to precision loss in JS and after the division we could end up with 42.000000001 results? That's also what `DecimalJs` fixes in this case.",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1575675704,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 36.16,
          "words": {
            "result": 3.6,
            "wordCount": 30,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1575675704"
      },
      {
        "content": "That is correct. I understand now why you're confused:\r\nThe value for the task would be\r\n`\"ISSUE|ISSUER|TASK\"`\r\nbecause it is inside the `issue`\r\nThe value for the Specification would be\r\n`\"REVIEW|ISSUER|SPECIFICATION\"`\r\nbecause it is inside the `pull`\r\nI display `Issue: Specification` and `Issue: Task` just to stick to our current display format. Maybe instead I could display `Review: Task` instead?",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1576567583,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 7,
                "score": 1
              },
              "p": {
                "elementCount": 8,
                "score": 1
              }
            },
            "result": 15
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 158.92,
          "words": {
            "result": 6.95,
            "wordCount": 65,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1576567583"
      },
      {
        "content": "I don't think is it relevant in this scenario because we are not manipulating big numbers. Decimaljs allows for non-precision loss on the operations because there is a lot of multiply / divide with floating points which can result in very long decimals due to Js nature.",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1577477616,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 38.072,
          "words": {
            "result": 5.37,
            "wordCount": 48,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1577477616"
      },
      {
        "content": "@whilefoo you are correct, these were wrongly used. I corrected `TASK` and replaced it by `SPECIFICATION` so we have:\r\n`\"ISSUE|ISSUER|SPECIFICATION\"` and `\"REVIEW|ISSUER|TASK\"`\r\nI used `ISSUER` for this because technically the issuer is not necessarily the assignee in both cases.\r\nFix within next PR:\r\nhttps://github.com/ubiquity-os/conversation-rewards/pull/14/commits/90e150f76073c9cfa16a251f8c1ae48a75aa5408",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1578162024,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 5,
                "score": 1
              },
              "p": {
                "elementCount": 5,
                "score": 1
              }
            },
            "result": 11
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 117.568,
          "words": {
            "result": 5.28,
            "wordCount": 47,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1578162024"
      },
      {
        "content": "Example of successful comment posting with results:\r\nhttps://github.com/Meniole/test/issues/1#issuecomment-2056572986",
        "id": 2056635516,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 29.88,
          "words": {
            "result": 1.05,
            "wordCount": 7,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#issuecomment-2056635516"
      },
      {
        "content": "@0x4007 I believe that if I had all the tests in this PR it will become enormous, maybe I ought to do it in a separate PR.",
        "id": 2063348339,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 2,
          "priority": 4,
          "relevance": 0.7,
          "reward": 26.424,
          "words": {
            "result": 3.29,
            "wordCount": 27,
            "wordValue": 0.2
          }
        },
        "type": "PULL_AUTHOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#issuecomment-2063348339"
      }
    ],
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOiIyMTAyMDg4MDAwMDAwMDAwMDAwMDAwIn0sIm5vbmNlIjoiODMwNzY0Mzc0NDY0OTk1ODkzMDQ2MTExMjg5NjM5MTY3MTAxMDY4ODYxMDI0MzYwMjM4ODE1MjAwNTgzNDY4MDA1Nzg3NTQ0MDE3NTUiLCJkZWFkbGluZSI6IjExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMzEyOTYzOTkzNSJ9LCJ0cmFuc2ZlckRldGFpbHMiOnsidG8iOiIweDREMDcwNGY0MDBENTdCYTkzZUVhODg3NjVDM0ZjREJEODI2ZENGYzQiLCJyZXF1ZXN0ZWRBbW91bnQiOiIyMTAyMDg4MDAwMDAwMDAwMDAwMDAwIn0sIm93bmVyIjoiMHhkOTUzMEYzZmJCRWExMWJlRDAxREMwOUU3OTMxOGYyZjIwMjIzNzE2Iiwic2lnbmF0dXJlIjoiMHgyNmFiMGE2N2I4MWFlMzZiMjQ3NjFkMDYwNjA2MGJlY2NhZGNjNTFhYTJmNTJlYzI4ZmY4OTUwMjI2M2FkNDNlMmEyNzQyYzIzNDkxZDkzMjU0YjM0NzhmMGQ0MGE1YjU3ZjkxZDFiNWRjYmJhMDUwZjI1MjU0NWZkZjRlM2RlNTFiIiwibmV0d29ya0lkIjoxMDB9XQ==",
    "task": {
      "multiplier": 1,
      "reward": 400
    },
    "total": 2102.088,
    "userId": 9807008
  },
  "whilefoo": {
    "comments": [
      {
        "content": "there are a couple of options:\r\n1. we let the conversation-rewards plugin generate and post the comment\r\n2. we put comment as output and then another module is responsible for posting it or let conversation-rewards generate rewards and permit-generation generate permits and a third module that uses output from previous plugins to make a comment and post it\r\n3. we let the conversation-rewards plugin generate the comment and pass it as a standard property like you suggested.\r\nIn theory 2. option sounds good to separate concerns but it's another plugin which means another call to github actions thus more latency, so for the sake of speed it'd go with option 1 or 3, but going with these 2 options would mean there will 1 comment for rewards summary and 1 comment for permits.\r\nI'm not sure if option 3 is any better than option 1 because the plugin already has a token that has permissions to post comments so passing it to the kernel doesn't make much difference.",
        "id": 2035427134,
        "score": {
          "formatting": {
            "content": {
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 6,
                "score": 1
              }
            },
            "result": 9
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.8,
          "reward": 15.402,
          "words": {
            "result": 7.99,
            "wordCount": 173,
            "wordValue": 0.1
          }
        },
        "type": "ISSUE_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2035427134"
      },
      {
        "content": "```suggestion\r\n    return result;\r\n```\r\nresolve is unnecessary here and some other places I saw it too",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);",
        "id": 1574427305,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 2
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 2.678,
          "words": {
            "result": 0.94,
            "wordCount": 14,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574427305"
      },
      {
        "content": "I'm not sure if it's a good idea to rely on logs for testing, is not possible to use output from the processor?",
        "diffHunk": "@@ -0,0 +1,41 @@\n+import { parseGitHubUrl } from \"../src/start\";\n+import { IssueActivity } from \"../src/issue-activity\";\n+import { Processor } from \"../src/parser/processor\";\n+import { UserExtractorModule } from \"../src/parser/user-extractor-module\";\n+import { server } from \"./__mocks__/node\";\n+import { DataPurgeModule } from \"../src/parser/data-purge-module\";\n+import userCommentResults from \"./__mocks__/results/user-comment-results.json\";\n+import dataPurgeResults from \"./__mocks__/results/data-purge-result.json\";\n+\n+const issueUrl = process.env.TEST_ISSUE_URL || \"https://github.com/ubiquity-os/comment-incentives/issues/22\";\n+\n+beforeAll(() => server.listen());\n+afterEach(() => server.resetHandlers());\n+afterAll(() => server.close());\n+\n+describe(\"Modules tests\", () => {\n+  const issue = parseGitHubUrl(issueUrl);\n+  const activity = new IssueActivity(issue);\n+\n+  beforeAll(async () => {\n+    await activity.init();\n+  });\n+\n+  it(\"Should extract users from comments\", async () => {\n+    const logSpy = jest.spyOn(console, \"log\");\n+    const processor = new Processor();\n+    processor[\"_transformers\"] = [new UserExtractorModule()];\n+    await processor.run(activity);\n+    processor.dump();\n+    expect(logSpy).toHaveBeenCalledWith(JSON.stringify(userCommentResults, undefined, 2));",
        "id": 1574441918,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 2.098,
          "words": {
            "result": 1.54,
            "wordCount": 25,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574441918"
      },
      {
        "content": "why so many nested functions? it becomes hard to read",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(",
        "id": 1574458540,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.507,
          "words": {
            "result": 0.71,
            "wordCount": 10,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574458540"
      },
      {
        "content": "is there a reason we are using Decimal.js instead of native BigInt?",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1574460099,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.616,
          "words": {
            "result": 0.88,
            "wordCount": 13,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574460099"
      },
      {
        "content": "Shouldn't task be issue opening item and specification is pull request opening item? At least that's how I understand from the code.",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1574487172,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 2.033,
          "words": {
            "result": 1.49,
            "wordCount": 24,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574487172"
      },
      {
        "content": "I assume this is a permit for task assignee, but where are other permits or is that not done yet?",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">",
        "id": 1574492061,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.896,
          "words": {
            "result": 1.28,
            "wordCount": 20,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1574492061"
      },
      {
        "content": "gotcha, I thought this html is for all users",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    function createIncentiveRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function buildIncentiveRow(commentScore: GithubCommentScore) {\n+        // Properly escape carriage returns for HTML rendering\n+        const formatting = stringify(commentScore.score?.formatting?.content).replace(/[\\n\\r]/g, \"&#13;\");\n+        return `\n+          <tr>\n+            <td>\n+              <h6>\n+                <a href=\"${commentScore.url}\" target=\"_blank\" rel=\"noopener\">${commentScore.content.replace(/(.{64})..+/, \"$1…\")}</a>\n+              </h6>\n+            </td>\n+            <td>\n+            <details>\n+              <summary>\n+                ${Object.values(commentScore.score?.formatting?.content || {}).reduce((acc, curr) => {\n+                  return acc.add(curr.score * curr.count);\n+                }, new Decimal(0))}\n+              </summary>\n+              <pre>${formatting}</pre>\n+             </details>\n+            </td>\n+            <td>${commentScore.score?.relevance || \"-\"}</td>\n+            <td>${commentScore.score?.reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      for (const issueComment of sorted.issues.comments) {\n+        content.push(buildIncentiveRow(issueComment));\n+      }\n+      for (const reviewComment of sorted.reviews) {\n+        content.push(buildIncentiveRow(reviewComment));\n+      }\n+      return content.join(\"\");\n+    }\n+\n+    return `\n+    <details>\n+      <summary>\n+        <b>\n+          <h3>\n+            <a href=\"${result.permitUrl}\" target=\"_blank\" rel=\"noopener\">",
        "id": 1575851470,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.445,
          "words": {
            "result": 0.65,
            "wordCount": 9,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1575851470"
      },
      {
        "content": "I can see from the example that it works correctly but when reading the code I get confused\r\nhttps://github.com/ubiquity-os/conversation-rewards/pull/12/files#diff-03f6b1f98f9f1df2651b65c46241c43e65d9544f7ea1de71e94255e757b3f2f0R108\r\nas I understand the if statement will be true if the comment is the first/opening comment of the issue or pull request so then it checks if it's issue then it will be TASK otherwise (if it's PR) it will be SPECIFICATION?",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1576482609,
        "score": {
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 6.386,
          "words": {
            "result": 3.38,
            "wordCount": 63,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1576482609"
      },
      {
        "content": "Ok so we need it for precise floating point calculations, in that case BigInt is not applicable.",
        "diffHunk": "@@ -0,0 +1,217 @@\n+import { Value } from \"@sinclair/typebox/value\";\n+import Decimal from \"decimal.js\";\n+import * as fs from \"fs\";\n+import { stringify } from \"yaml\";\n+import configuration from \"../configuration/config-reader\";\n+import githubCommentConfig, { GithubCommentConfiguration } from \"../configuration/github-comment-config\";\n+import { getOctokitInstance } from \"../get-authentication-token\";\n+import { CommentType, IssueActivity } from \"../issue-activity\";\n+import { parseGitHubUrl } from \"../start\";\n+import { getPayoutConfigByNetworkId } from \"../types/payout\";\n+import program from \"./command-line\";\n+import { GithubCommentScore, Module, Result } from \"./processor\";\n+\n+/**\n+ * Posts a GitHub comment according to the given results.\n+ */\n+export class GithubCommentModule implements Module {\n+  private readonly _configuration: GithubCommentConfiguration = configuration.githubComment;\n+  private readonly _debugFilePath = \"./output.html\";\n+\n+  async transform(data: Readonly<IssueActivity>, result: Result): Promise<Result> {\n+    const bodyArray: (string | undefined)[] = [];\n+\n+    for (const [key, value] of Object.entries(result)) {\n+      result[key].evaluationCommentHtml = this._generateHtml(key, value);\n+      bodyArray.push(result[key].evaluationCommentHtml);\n+    }\n+    const body = bodyArray.join(\"\");\n+    if (this._configuration.debug) {\n+      fs.writeFileSync(this._debugFilePath, body);\n+    }\n+    if (this._configuration.post) {\n+      try {\n+        const octokit = getOctokitInstance();\n+        const { owner, repo, issue_number } = parseGitHubUrl(program.opts().issue);\n+\n+        await octokit.issues.createComment({\n+          body,\n+          repo,\n+          owner,\n+          issue_number,\n+        });\n+      } catch (e) {\n+        console.error(`Could not post GitHub comment: ${e}`);\n+      }\n+    }\n+    return Promise.resolve(result);\n+  }\n+\n+  get enabled(): boolean {\n+    if (!Value.Check(githubCommentConfig, this._configuration)) {\n+      console.warn(\"Invalid configuration detected for GithubContentModule, disabling.\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  _generateHtml(username: string, result: Result[0]) {\n+    const sorted = result.comments?.reduce<{\n+      issues: { task: GithubCommentScore | null; comments: GithubCommentScore[] };\n+      reviews: GithubCommentScore[];\n+    }>(\n+      (acc, curr) => {\n+        if (curr.type & CommentType.ISSUE) {\n+          if (curr.type & CommentType.TASK) {\n+            acc.issues.task = curr;\n+          } else {\n+            acc.issues.comments.push(curr);\n+          }\n+        } else if (curr.type & CommentType.REVIEW) {\n+          acc.reviews.push(curr);\n+        }\n+        return acc;\n+      },\n+      { issues: { task: null, comments: [] }, reviews: [] }\n+    );\n+\n+    function createContributionRows() {\n+      const content: string[] = [];\n+\n+      if (!sorted) {\n+        return content.join(\"\");\n+      }\n+\n+      function generateContributionRow(\n+        view: string,\n+        contribution: string,\n+        count: number,\n+        reward: number | Decimal | undefined\n+      ) {\n+        return `\n+          <tr>\n+            <td>${view}</td>\n+            <td>${contribution}</td>\n+            <td>${count}</td>\n+            <td>${reward || \"-\"}</td>\n+          </tr>`;\n+      }\n+\n+      if (result.task?.reward) {\n+        content.push(generateContributionRow(\"Issue\", \"Task\", 1, result.task.reward));\n+      }\n+      if (sorted.issues.task) {\n+        content.push(generateContributionRow(\"Issue\", \"Specification\", 1, sorted.issues.task.score?.reward));\n+      }\n+      if (sorted.issues.comments.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Issue\",\n+            \"Comment\",\n+            sorted.issues.comments.length,\n+            sorted.issues.comments.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))\n+          )\n+        );\n+      }\n+      if (sorted.reviews.length) {\n+        content.push(\n+          generateContributionRow(\n+            \"Review\",\n+            \"Comment\",\n+            sorted.reviews.length,\n+            sorted.reviews.reduce((acc, curr) => acc.add(curr.score?.reward ?? 0), new Decimal(0))",
        "id": 1578040543,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.787,
          "words": {
            "result": 1.11,
            "wordCount": 17,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1578040543"
      },
      {
        "content": "why is it `ISSUER` which is meant for author of issue/review. wouldn't it make more sense to use `ASIGNEE`?\r\nisn't specification the first comment of the issue so how is it inside PR?",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1578050965,
        "score": {
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 5.49,
          "words": {
            "result": 2.1,
            "wordCount": 36,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1578050965"
      },
      {
        "content": "this makes more sense!",
        "diffHunk": "@@ -19,12 +19,42 @@ import {\n } from \"./start\";\n \n export enum CommentType {\n+  /**\n+   * Review related item\n+   */\n   REVIEW = 0b1,\n+  /**\n+   * Issue related item\n+   */\n   ISSUE = 0b10,\n+  /**\n+   * User assigned to the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ASSIGNEE = 0b100,\n+  /**\n+   * The author of the {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n   ISSUER = 0b1000,\n+  /**\n+   * A user that is part of the organization or owner of the repo\n+   */\n   COLLABORATOR = 0b10000,\n+  /**\n+   * A user that is NOT part of the organization nor owner of the repo\n+   */\n   CONTRIBUTOR = 0b100000,\n+  /**\n+   * A user comment action on a {@link CommentType.ISSUE} or {@link CommentType.REVIEW}\n+   */\n+  COMMENTED = 0b1000000,\n+  /**\n+   * Pull request opening item\n+   */\n+  TASK = 0b10000000,",
        "id": 1579556333,
        "score": {
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 0.25,
          "priority": 4,
          "relevance": 0.7,
          "reward": 1.224,
          "words": {
            "result": 0.32,
            "wordCount": 4,
            "wordValue": 0.1
          }
        },
        "type": "PULL_CONTRIBUTOR",
        "url": "https://github.com/ubiquity-os/conversation-rewards/pull/12#discussion_r1579556333"
      }
    ],
    "total": 43.562,
    "userId": 139262667
  }
}