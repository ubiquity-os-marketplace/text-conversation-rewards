{
  "0x4007": {
    "comments": [
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "@whilefoo rfc on how we can deal with comment outputs. Perhaps we can have a standard recognized property on the output interface? Then the kernel can decide whether to pass it around or something. \r\n\r\n```ts\r\ninterface PluginOutput {\r\n  comment: string; // html comment\r\n  rewards: Rewards; // { \"whilefoo\": \"500\", \"token\": \"0x0\" } etc\r\n}\r\n```",
        "id": 2030164289,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 54.50875000000002,
            "score": 0.9450875000000002,
            "sentences": 4,
            "syllables": 78
          },
          "relevance": 0.8,
          "reward": 14.976,
          "words": {
            "result": 1.65,
            "wordCount": 47,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-01T17:02:54Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2030164289"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "I think you should fork from and overtake that second pull due to us being behind schedule",
        "id": 2033488255,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 75.12117647058825,
            "score": 0.8487882352941175,
            "sentences": 1,
            "syllables": 23
          },
          "relevance": 0.8,
          "reward": 7.776,
          "words": {
            "result": 0.94,
            "wordCount": 17,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-03T04:04:16Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2033488255"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "I think the most pure architecture would be that plugins can NOT inherit (write) authentication (only read if possible) of the kernel. As a consequence, no plugin should be able to post directly any issue. Ideally it should only be the kernel with a direct interface to issues. Plugins should just output comment HTML and the kernel can post it all in a single comment at the end of the webhook event invocation chain.\r\n\r\n\r\n\r\nCould be interesting to have a dedicated plugin to handle commenting, but because this seems like such an essential capability, I would more carefully consider the pros/cons of including this within the kernel. \r\n\r\n- On one hand, I really like the idea of making the kernel as pure and lean as possible\r\n- On the other hand there are practical considerations that if every plugin standard output interface includes `comment:` and then we don't have the `comment` capability available (the comment plugin is not included in the config) then why is this a standard output property required on every plugin?\r\n\r\n\r\n\r\n\r\n\r\nI'm not concerned about latency now. Besides we can port any plugin to Cloudflare Workers (or combine several inside a single Worker) when we are ready to fix latency issues. To be honest though, except for setting labels, I have no problem with latency (like with permit generation) so there's no need to overengineer yet. I also love the GitHub Actions logs being available for easy debugging, and the fact that they are super generous with the compute. \r\n\r\nGiven the entire conversation and all the considerations, I definitely think we should do option 3. \r\n\r\nThis separates concerns the best, which will allow our plugin ecosystem to grow the fastest.",
        "id": 2036355445,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "li": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 5,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 10
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 45.88453947368424,
            "score": 0.8588453947368424,
            "sentences": 12,
            "syllables": 461
          },
          "relevance": 0.8,
          "reward": 43.104,
          "words": {
            "result": 0.71,
            "wordCount": 285,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-04T07:07:18Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036355445"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "I know JSON makes things more complicated than it needs to be with serialization/transport. Then we have problems like this [https://github.com/ubiquity-os/conversation-rewards/issues/18.](https://github.com/ubiquity-os/conversation-rewards/issues/18.) If the comment property is ONLY meant to be used for GitHub comments, then transporting HTML only is the most sensible. Besides, there's no other metadata thats necessary within the `comment` property, which is the main point of sending a JSON object (it has multiple properties.) \r\n\r\nAs a somewhat side note: there should also not be any variables inside of the HTML. We could look it as like server-side-rendering (or in this case, plugin-side-rendering) handle producing the final HTML output and then output it as a single string of html entities. \r\n\r\n\r\n\r\nWe are currently using `mdast` in `@ubiquity-os/comment-incentives` to generate virtual DOMs. No `window` needed.\r\n\r\n\r\n\r\nIf we agree that this is considered as technical debt, and that we are accruing this so that we can get back on schedule, ok.",
        "id": 2036370459,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 4,
                "score": 1
              },
              "p": {
                "elementCount": 4,
                "score": 1
              }
            },
            "result": 9
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 60.868714285714304,
            "score": 0.991312857142857,
            "sentences": 10,
            "syllables": 256
          },
          "relevance": 0.8,
          "reward": 43.68,
          "words": {
            "result": 1.52,
            "wordCount": 159,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-04T07:15:45Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036370459"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "Going back to my \"plugin-side-rendering\" mention, the data manipulation happens inside of the logic of the plugin. Then when the plugin is finally done with all of its compute, it emits a single string in the `comment` output property. This string is the final, rendered HTML. \r\n\r\nThe `comment` output is not intended to be consumed by other plugins. In most cases, the kernel will concatenate all the `comment` outputs from every plugin and post a single comment at the end. Plugins will consume the `metadata` property output which will include raw values to work with. I forget where I originally proposed this, but imagine something like:\r\n```typescript\r\n\r\ntype HtmlString = string;\r\ntype RequestedPermits = { username: string; amount: string; token: string; }[]\r\n \r\ninterface PluginOutput {\r\n   metadata: Record<string, any>;\r\n   comment: HtmlString;\r\n   rewards: RequestedPermits;\r\n}\r\n```",
        "id": 2036393020,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 5,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 47.78581395348837,
            "score": 0.8778581395348837,
            "sentences": 7,
            "syllables": 214
          },
          "relevance": 0.8,
          "reward": 35.2,
          "words": {
            "result": 1.71,
            "wordCount": 129,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-04T07:27:54Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036393020"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "The proposed `comment` output is intended for ease of composability for MOST situations, basically that the output from one plugin would just be appended to the final rendered comment. For simple plugin configurations (plugins not modifying the output results of others) this seems like straightforward architecture. \r\n\r\nHowever, as we know, there will be situations where a subsequent plugin will consider the results of a previous plugin, which means it would need to change the comment that is rendered. \r\n\r\nIn this situation the subsequent plugin should clobber the output of the previous plugin. It is now clear to be that this will be a new challenge to express to the kernel that it should ignore the comment output of a previous plugin. I suppose it would be straightforward in the metadata using the plugin ID i.e. `{ \"silences\": [\"ubiquity-os/conversation-rewards\"] }`.\r\n\r\n\r\n\r\nI think that comments should be handled from within the kernel. There should not be a separate comment plugin. Read my explanation [here](https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036355445). \r\n\r\n\r\n### Inputs\r\n\r\nFor completeness of my [previous comment](https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036393020):\r\n\r\n```typescript\r\n\r\ntype PluginId = string; // i.e. `ubiquity-os/conversation-rewards` `ubiquity-os/daemon-pricing`\r\n \r\ninterface PluginInput {\r\n   metadata: Record<PluginId, any>;\r\n   context: GitHubEventContext;\r\n}\r\n```\r\n\r\nNotice that we should not pass in the HTML of other plugins. Instead, just the metadata (\"computed\") values from the previous plugins.",
        "id": 2036433646,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 3,
                "score": 1
              },
              "h3": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 6,
                "score": 1
              },
              "pre": {
                "elementCount": 1,
                "score": 0
              }
            },
            "result": 10
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 49.64124922118381,
            "score": 0.8964124922118382,
            "sentences": 15,
            "syllables": 361
          },
          "relevance": 0.8,
          "reward": 45.184,
          "words": {
            "result": 1.13,
            "wordCount": 214,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-04T07:49:05Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036433646"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "I understand your concern and I would need to put more thought into composability. Maybe the `comment` proposal is bad after all due to your point. It's only useful with simple plugins, but for more complex ones your point is valid. \r\n\r\nI need help to think through how any partner in the future can create new plugins that modify \r\n1. permit reward amounts \r\n2. XP reward amounts\r\n\r\nI don't like the idea of having a single monolithic rewards generation plugin that wraps all the ways possible to compute rewards (i.e. time estimation, comment rewards, review rewards etc)",
        "id": 2036516869,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 2,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 6
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 60.76687074829937,
            "score": 0.9923312925170064,
            "sentences": 6,
            "syllables": 150
          },
          "relevance": 0.8,
          "reward": 32.608,
          "words": {
            "result": 1.85,
            "wordCount": 98,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-04T08:26:34Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036516869"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "I see, so you're suggesting that we must annotate each comment as well in order to properly handle the scoring at the end?\n\nOff hand I think there's:\n\n1. Specification \n2. Issue comment\n3. Pull request comment (a normal comment on a pull request, not related to posting a \"review\"\n4. Pull request review comment (associated with a \"review state\" I.e. approved, left comments, requested changes)\n\nI suppose we need a better naming convention for the pull related ones. They are considered as separate entities according to the GitHub api. They require different methods to obtain both types.",
        "id": 2053332029,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "li": {
                "elementCount": 4,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 59.60109106529211,
            "score": 0.9960109106529211,
            "sentences": 6,
            "syllables": 150
          },
          "relevance": 0.8,
          "reward": 36.768,
          "words": {
            "result": 1.85,
            "wordCount": 97,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-13T04:06:19Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2053332029"
      },
      {
        "commentType": "ISSUE_COLLABORATOR",
        "content": "Consider calling it \"contributor\" and \"collaborator\" as that is how it is presented on the GitHub APIs as I recall. \n\nAlso I think you forgot about the \"review comments\"",
        "id": 2055783331,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 52.08991379310348,
            "score": 0.9208991379310347,
            "sentences": 2,
            "syllables": 48
          },
          "relevance": 0.8,
          "reward": 13.504,
          "words": {
            "result": 1.31,
            "wordCount": 29,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-15T07:15:04Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2055783331"
      }
    ],
    "events": {
      "issue.commented": {
        "count": 9,
        "reward": 0
      },
      "issue.labeled": {
        "count": 1,
        "reward": 0
      },
      "issue.mentioned": {
        "count": 2,
        "reward": 0
      },
      "issue.subscribed": {
        "count": 2,
        "reward": 0
      },
      "pull_request.commented": {
        "count": 1,
        "reward": 0
      },
      "pull_request.mentioned": {
        "count": 2,
        "reward": 0
      },
      "pull_request.received.review_requested": {
        "count": 2,
        "reward": 0
      },
      "pull_request.reopened": {
        "count": 1,
        "reward": 0
      },
      "pull_request.review_comment": {
        "count": 21,
        "reward": 0
      },
      "pull_request.reviewed.commented": {
        "count": 6,
        "reward": 0
      },
      "pull_request.subscribed": {
        "count": 2,
        "reward": 0
      },
      "reaction.received.+1": {
        "count": 2,
        "reward": 0
      },
      "reaction.received.eyes": {
        "count": 2,
        "reward": 0
      },
      "reaction.received.rocket": {
        "count": 1,
        "reward": 0
      },
      "reaction.sent.+1": {
        "count": 1,
        "reward": 0
      },
      "reaction.sent.eyes": {
        "count": 2,
        "reward": 0
      }
    },
    "payoutMode": "permit",
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOnsidHlwZSI6IkJpZ051bWJlciIsImhleCI6IjB4MGVjOWRjNGFhNGM2OTAwMDAwIn19LCJub25jZSI6IjMzOTI5NDE3NjI3OTM5NzU1OTMxNzgxMTE1NjU5ODM3OTc0NzU4OTQwMzc0OTU0MDQxMzEyODYzODI3ODA0MTE2ODc3MDgzNTI4ODgiLCJkZWFkbGluZSI6IjAifSwidHJhbnNmZXJEZXRhaWxzIjp7InRvIjoiMHg0RDA3MDRmNDAwRDU3QmE5M2VFYTg4NzY1QzNGY0RCRDgyNmRDRmM0IiwicmVxdWVzdGVkQW1vdW50Ijp7InR5cGUiOiJCaWdOdW1iZXIiLCJoZXgiOiIweDBlYzlkYzRhYTRjNjkwMDAwMCJ9fSwib3duZXIiOiIweGQ5NTMwRjNmYkJFYTExYmVEMDFEQzA5RTc5MzE4ZjJmMjAyMjM3MTYiLCJzaWduYXR1cmUiOiIweDlhZjBhYjhmOTY5ZGIxYzBjY2I3MmQyNzA0Zjg0NGU4MWExNjdjZjE2ZDRiZTYyNGJkZjVhMWIxNmQxNmJmMzMwNTcwZDA2M2JmOTc4YWRmZjM5NmVjMWVkNjhmMzBiYWZiN2UwMTNiY2NiNTgyMGZmN2MxNjgzOTFkODFkNmZhMWMiLCJuZXR3b3JrSWQiOjEwMH1d",
    "total": 272.8,
    "userId": 4975670,
    "walletAddress": "0x1"
  },
  "gentlementlegen": {
    "comments": [
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "This needs [https://github.com/ubiquity-os/conversation-rewards/pull/7](https://github.com/ubiquity-os/conversation-rewards/pull/7) to be merged first. Also probably needs [https://github.com/ubiquity-os/permit-generation/pull/2](https://github.com/ubiquity-os/permit-generation/pull/2) to be able to generate the permits properly.",
        "id": 2033404518,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 52.9251785714286,
            "score": 0.929251785714286,
            "sentences": 4,
            "syllables": 60
          },
          "relevance": 0.8,
          "reward": 19.968,
          "words": {
            "result": 1.88,
            "wordCount": 17,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-03T02:05:44Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2033404518"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "To me 1 is the most straightforward to do for few reasons:\r\n- the comment reward plugin has all the needed data already\r\n- it can import the [https://github.com/ubiquity-os/permit-generation](https://github.com/ubiquity-os/permit-generation) to generate permits itself\r\n- if it is done this way it can be used as a complete standalone without the kernel\r\n\r\n3 might make more sense in terms of architecture however. In such case the kernel should pass down results. It is more of an architecture question. Although, if we ever have other plugins in the flow that have influence on the total incentives, it would make sense to go through the kernel to aggregate the total result.",
        "id": 2036174312,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 60.83172972972976,
            "score": 0.9916827027027024,
            "sentences": 5,
            "syllables": 162
          },
          "relevance": 0.8,
          "reward": 44.256,
          "words": {
            "result": 3.66,
            "wordCount": 104,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T04:33:44Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036174312"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "I think each plugin should output JSON not html as it is not reliable to parse nor manipulate and requires `window` instance to be instantiated which is annoying on `node` based projects. \r\n\r\nHaving a plugin handling commenting seems quite weird as commenting is done by calling Octokit and the REST api which is already a library by itself, so no need to encapsulate it within another one to do the same thing.\r\n\r\nMy view on this, is to finalize [https://github.com/ubiquity-os/permit-generation/issues/5](https://github.com/ubiquity-os/permit-generation/issues/5) to import it withing the `conversation-reward` that will post the comment itself as well, otherwise the architecture will be quite convoluted doing ping pong with everything.",
        "id": 2036367126,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "code": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 7
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 45.23635869565217,
            "score": 0.8523635869565217,
            "sentences": 4,
            "syllables": 180
          },
          "relevance": 0.8,
          "reward": 42.784,
          "words": {
            "result": 3.65,
            "wordCount": 106,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T07:13:44Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036367126"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "If you want to manipulate and convey data, HTML really is not made for this. If you want something formatted similarly but made for data we can use XML format.\r\nThe new comment reward actually does instantiate a DOM through [JSDOM](https://github.com/ubiquity-os/conversation-rewards/blob/ba434761281446a23566cd02c68bd3b0e79d4eb1/src/parser/formatting-evaluator-module.ts#L80) to make things way simpler instead of using Regex everywhere which is highly unreliable. But there it makes sense because we are parsing comments from an HTML page content.\r\n\r\nBiggest advantage from this is to have the comment reward fully standalone, while easy to integrate with the kernel.\r\n\r\nIf we do something that handles the comment it means each and every module has to send it there and that module should understand every different content / format we send which would be way easier if the module itself handled its own comments, formatting wise.",
        "id": 2036385985,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 53.47860696517415,
            "score": 0.9347860696517415,
            "sentences": 6,
            "syllables": 207
          },
          "relevance": 0.8,
          "reward": 30.208,
          "words": {
            "result": 3.37,
            "wordCount": 134,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T07:24:01Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036385985"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "But then how do we consider the formatting of that output?\r\n\r\nPractical case: we want to post a comment when a user queries a wallet. That comment is 'user name': 'wallet 0x0'\r\nKernel calls the comment plugin, saying that it wants a comment to be posted. Should the Kernel send the rendering it wants, should the comment plugin transform the data to HTML?\r\n\r\nThen, comment-reward wants to post the results. Should ask the Kernel to call the comment plugin, but then formatting is different. Should the Kernel notify the comment plugin that it wants a different output formatting? Should the Kernel compute beforehand the HTML and send it to the comment plugin?\r\n\r\nMight be something I don't grasp there. Because I do understand your use case but it seems to be very deterministic on what is the purpose of the plugins which kinda defeats the purpose of having plugins, looks more like a monolithic approach to me",
        "id": 2036411811,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "p": {
                "elementCount": 4,
                "score": 1
              }
            },
            "result": 4
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 66.72291509433965,
            "score": 0.9327708490566035,
            "sentences": 10,
            "syllables": 233
          },
          "relevance": 0.8,
          "reward": 28.8,
          "words": {
            "result": 3.03,
            "wordCount": 159,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T07:37:30Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036411811"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "This can work, but we skyrocket coupling and to me defeat purpose of plugins that should be unaware of each other. If any plugin has to understand the result of a previous plugin, it means these plugins have necessarily to co-exist so basically they become a single plugin with no purpose to split them.",
        "id": 2036458775,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 1
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 49.715227272727276,
            "score": 0.8971522727272727,
            "sentences": 2,
            "syllables": 84
          },
          "relevance": 0.8,
          "reward": 18.208,
          "words": {
            "result": 3.48,
            "wordCount": 55,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T08:01:43Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036458775"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "@pavlovcik To mitigate that that's why inside the comment reward itself I also integrated that `Module` principle so code is not coupled tightly and easy to build on. There is as usual pros and cons to both approaches (splitting or not) but biggest pro is that comments get evaluated once in the same spot, so we save calls to OpenAPI and speed up the process. Also makes it only one configuration file in one location. We need to think about our best options there.",
        "id": 2036535332,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 1,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 2
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 61.84977941176473,
            "score": 0.9815022058823527,
            "sentences": 4,
            "syllables": 124
          },
          "relevance": 0.8,
          "reward": 23.744,
          "words": {
            "result": 3.73,
            "wordCount": 85,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-04T08:33:57Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2036535332"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "I realized that to carry this task properly we need to handle flags for comment more delicately as they only indicate if the comment is `ISSUE | REVIEW` with the level `MEMBER | CONTRIBUTOR` etc. but doesn't specify if it is from a task, a specification and so on. Tags should be added to the config properly as well.",
        "id": 2051094255,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 2,
                "score": 1
              },
              "p": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 3
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 58.853045977011504,
            "score": 0.988530459770115,
            "sentences": 3,
            "syllables": 88
          },
          "relevance": 0.8,
          "reward": 27.104,
          "words": {
            "result": 3.53,
            "wordCount": 58,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-12T06:44:31Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2051094255"
      },
      {
        "commentType": "ISSUE_AUTHOR",
        "content": "Agreed, I think currently there are 3 possible things to annotate on the comments:\r\n- `SPECIFICATION` for the issue itself, `TASK` for the related PR fixing it, or simply `COMMENT`\r\n- `MEMBER` or `CONTRIBUTOR` for the status of the member\r\n- `REVIEW` or `ISSUE` for where the comment was added\r\n\r\nI think this shall cover all cases.",
        "id": 2054424028,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "code": {
                "elementCount": 7,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 2,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 13
          },
          "multiplier": 1,
          "priority": 4,
          "readability": {
            "fleschKincaid": 23.558333333333337,
            "score": 0.6355833333333334,
            "sentences": 1,
            "syllables": 82
          },
          "relevance": 0.8,
          "reward": 62.72,
          "words": {
            "result": 3.46,
            "wordCount": 54,
            "wordValue": 0.2
          }
        },
        "timestamp": "2024-04-15T02:27:24Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2054424028"
      },
      {
        "commentType": "ISSUE_SPECIFICATION",
        "content": "In the v1 of the Ubiquibot, when a result gets evaluated, a recap is posted to the related issue with a summary and details of the rewards as well as the link to the rewards themselves Example: [https://github.com/ubiquity/cloudflare-deploy-action/issues/9#issuecomment-2028623754](https://github.com/ubiquity/cloudflare-deploy-action/issues/9#issuecomment-2028623754)\r\n\r\nThe same logic should be applied in the v2 version by creating a new Module responsible to post that comment. This module will receive a similar input than the one mentioned [here](https://github.com/ubiquity/cloudflare-deploy-action/issues/9#issuecomment-2028623754)\r\n\r\nThe module should be:\r\n- possible to enable / disable\r\n- eventually configurable (what data to show / hide)\r\n- coming with tests",
        "id": 2218638141,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "a": {
                "elementCount": 1,
                "score": 1
              },
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "p": {
                "elementCount": 3,
                "score": 1
              },
              "ul": {
                "elementCount": 1,
                "score": 1
              }
            },
            "result": 8
          },
          "multiplier": 1,
          "priority": 1,
          "readability": {
            "fleschKincaid": 35.555884353741504,
            "score": 0.7555588435374151,
            "sentences": 3,
            "syllables": 160
          },
          "relevance": 1,
          "reward": 12.11,
          "words": {
            "result": 1.87,
            "wordCount": 87,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-01T16:42:17Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issue-2218638141"
      }
    ],
    "events": {
      "issue.closed": {
        "count": 1,
        "reward": 0
      },
      "issue.commented": {
        "count": 10,
        "reward": 0
      },
      "issue.cross-referenced": {
        "count": 4,
        "reward": 0
      },
      "issue.labeled": {
        "count": 2,
        "reward": 0
      },
      "issue.mentioned": {
        "count": 1,
        "reward": 0
      },
      "issue.subscribed": {
        "count": 1,
        "reward": 0
      },
      "issue.unlabeled": {
        "count": 1,
        "reward": 0
      },
      "pull_request.closed": {
        "count": 1,
        "reward": 0
      },
      "pull_request.commented": {
        "count": 2,
        "reward": 0
      },
      "pull_request.cross-referenced": {
        "count": 2,
        "reward": 0
      },
      "pull_request.head_ref_deleted": {
        "count": 1,
        "reward": 0
      },
      "pull_request.merged": {
        "count": 1,
        "reward": 0
      },
      "pull_request.ready_for_review": {
        "count": 1,
        "reward": 0
      },
      "pull_request.review_comment": {
        "count": 22,
        "reward": 0
      },
      "pull_request.sent.review_requested": {
        "count": 5,
        "reward": 0
      },
      "reaction.received.+1": {
        "count": 2,
        "reward": 0
      },
      "reaction.received.eyes": {
        "count": 2,
        "reward": 0
      },
      "reaction.sent.+1": {
        "count": 5,
        "reward": 0
      },
      "reaction.sent.eyes": {
        "count": 2,
        "reward": 0
      },
      "reaction.sent.rocket": {
        "count": 1,
        "reward": 0
      }
    },
    "payoutMode": "permit",
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOnsidHlwZSI6IkJpZ051bWJlciIsImhleCI6IjB4MjY3YmRlOGJjNzJiNWIwMDAwIn19LCJub25jZSI6IjgzMDc2NDM3NDQ2NDk5NTg5MzA0NjExMTI4OTYzOTE2NzEwMTA2ODg2MTAyNDM2MDIzODgxNTIwMDU4MzQ2ODAwNTc4NzU0NDAxNzU1IiwiZGVhZGxpbmUiOiIwIn0sInRyYW5zZmVyRGV0YWlscyI6eyJ0byI6IjB4NEQwNzA0ZjQwMEQ1N0JhOTNlRWE4ODc2NUMzRmNEQkQ4MjZkQ0ZjNCIsInJlcXVlc3RlZEFtb3VudCI6eyJ0eXBlIjoiQmlnTnVtYmVyIiwiaGV4IjoiMHgyNjdiZGU4YmM3MmI1YjAwMDAifX0sIm93bmVyIjoiMHhkOTUzMEYzZmJCRWExMWJlRDAxREMwOUU3OTMxOGYyZjIwMjIzNzE2Iiwic2lnbmF0dXJlIjoiMHgxZGM5YzQ4NWExZDdmNzA5OGZmZjY0YzQ4ZGJiYTYzNTA1ZGEyN2JmM2RkNjA5YTY4NzM5MjNmM2FiZGI3MmI2NjhhNzdiZWFmYzY2YjlkZGE0MjJlYTI0YjcxYTk2MmFhMDRhNjUxZjQ5MTJmYzIwZjY1OTdjYjc2NjhlZGE0OTFiIiwibmV0d29ya0lkIjoxMDB9XQ==",
    "task": {
      "multiplier": 1,
      "reward": 400,
      "timestamp": "2024-04-25T14:29:35Z",
      "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#event-12609679506"
    },
    "total": 709.902,
    "userId": 9807008,
    "walletAddress": "0x1"
  },
  "gitcoindev": {
    "events": {
      "pull_request.received.review_requested": {
        "count": 1,
        "reward": 0
      }
    },
    "payoutMode": "permit",
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOnsidHlwZSI6IkJpZ051bWJlciIsImhleCI6IjB4MDAifX0sIm5vbmNlIjoiNTY1NTM0OTQ0NTQwOTcwMTg3NzIyMTY2MTk1Mjc1OTkyMTU3NTA0NDU2MjgyNjY2OTYyMDczNzE2MTUzNzU1MTMyMzk2MzYwMzIwMTgiLCJkZWFkbGluZSI6IjAifSwidHJhbnNmZXJEZXRhaWxzIjp7InRvIjoiMHg0RDA3MDRmNDAwRDU3QmE5M2VFYTg4NzY1QzNGY0RCRDgyNmRDRmM0IiwicmVxdWVzdGVkQW1vdW50Ijp7InR5cGUiOiJCaWdOdW1iZXIiLCJoZXgiOiIweDAwIn19LCJvd25lciI6IjB4ZDk1MzBGM2ZiQkVhMTFiZUQwMURDMDlFNzkzMThmMmYyMDIyMzcxNiIsInNpZ25hdHVyZSI6IjB4YzE0YjNkODI4ODg3NGFkZTQ0NDc2NzRkMTIwYWUxY2EwMzdiMGUwYzA5ZGRkZmQ1MmNlY2FiNDg2ODBjZDRlZTM2MTI2YWQ3ZjY0MTg5MTIwODgyOWZiZWQ4OTQwOGMzMDFkMTkxNTFlMGMzYjBkYmMzN2M5OGEzZjVhMjdkZGUxYyIsIm5ldHdvcmtJZCI6MTAwfV0=",
    "total": 0,
    "userId": 88761781,
    "walletAddress": "0x1"
  },
  "whilefoo": {
    "comments": [
      {
        "commentType": "ISSUE_CONTRIBUTOR",
        "content": "there are a couple of options:\r\n1. we let the conversation-rewards plugin generate and post the comment\r\n2. we put comment as output and then another module is responsible for posting it or let conversation-rewards generate rewards and permit-generation generate permits and a third module that uses output from previous plugins to make a comment and post it\r\n3. we let the conversation-rewards plugin generate the comment and pass it as a standard property like you suggested.\r\n\r\nIn theory 2. option sounds good to separate concerns but it's another plugin which means another call to github actions thus more latency, so for the sake of speed it'd go with option 1 or 3, but going with these 2 options would mean there will 1 comment for rewards summary and 1 comment for permits.\r\nI'm not sure if option 3 is any better than option 1 because the plugin already has a token that has permissions to post comments so passing it to the kernel doesn't make much difference.",
        "id": 2035427134,
        "score": {
          "authorship": 1,
          "formatting": {
            "content": {
              "li": {
                "elementCount": 3,
                "score": 1
              },
              "ol": {
                "elementCount": 1,
                "score": 0
              },
              "p": {
                "elementCount": 2,
                "score": 1
              }
            },
            "result": 5
          },
          "multiplier": 0.25,
          "priority": 4,
          "readability": {
            "fleschKincaid": 34.32468930635841,
            "score": 0.743246893063584,
            "sentences": 4,
            "syllables": 263
          },
          "relevance": 0.8,
          "reward": 6.272,
          "words": {
            "result": 1.42,
            "wordCount": 173,
            "wordValue": 0.1
          }
        },
        "timestamp": "2024-04-03T19:34:29Z",
        "url": "https://github.com/ubiquity-os/conversation-rewards/issues/5#issuecomment-2035427134"
      }
    ],
    "events": {
      "issue.commented": {
        "count": 1,
        "reward": 0
      },
      "issue.mentioned": {
        "count": 3,
        "reward": 0
      },
      "issue.subscribed": {
        "count": 3,
        "reward": 0
      },
      "pull_request.received.review_requested": {
        "count": 2,
        "reward": 0
      },
      "pull_request.review_comment": {
        "count": 11,
        "reward": 0
      },
      "pull_request.reviewed.approved": {
        "count": 1,
        "reward": 0
      },
      "pull_request.reviewed.changes_requested": {
        "count": 1,
        "reward": 0
      },
      "reaction.received.+1": {
        "count": 3,
        "reward": 0
      },
      "reaction.sent.+1": {
        "count": 1,
        "reward": 0
      }
    },
    "payoutMode": "permit",
    "permitUrl": "https://pay.ubq.fi?claim=W3sidHlwZSI6ImVyYzIwLXBlcm1pdCIsInBlcm1pdCI6eyJwZXJtaXR0ZWQiOnsidG9rZW4iOiIweGU5MUQxNTNFMGI0MTUxOEEyQ2U4RGQzRDc5NDRGYTg2MzQ2M2E5N2QiLCJhbW91bnQiOnsidHlwZSI6IkJpZ051bWJlciIsImhleCI6IjB4NTcwYTllYzRmZjQwMDAwMCJ9fSwibm9uY2UiOiI2Mjk3MDU5MDYxNTg4MTIyMTI3NDMxNjkxMDU2NzcwMTk1MzQzNTA4NTYwMzA5OTc1MTIyNDMxNjkwOTE4MzA3OTUzOTg5Mzg2MzkxNCIsImRlYWRsaW5lIjoiMCJ9LCJ0cmFuc2ZlckRldGFpbHMiOnsidG8iOiJbbW9ja10gQ291bGQgbm90IGZpbmQgd2FsbGV0IGZvciB1c2VyIDEzOTI2MjY2NyIsInJlcXVlc3RlZEFtb3VudCI6eyJ0eXBlIjoiQmlnTnVtYmVyIiwiaGV4IjoiMHg1NzBhOWVjNGZmNDAwMDAwIn19LCJvd25lciI6IjB4ZDk1MzBGM2ZiQkVhMTFiZUQwMURDMDlFNzkzMThmMmYyMDIyMzcxNiIsInNpZ25hdHVyZSI6IjB4MjJlNzgxNWZhOTk0M2YwYmYzMjllYzI2Y2M3MzVjMjM3ODQ4N2I0MjZmYThmMmZjZmQzZTJjZDEyMDcwMGU1ZDQ1ZDBlZDQxYTlhYTc5NmZkNDBjZTYyNDdkNDdlNjc1YjNmZjMxODhiZGE5OWEzZTEzMTY1YTdhOGIwOGI4MjUxYiIsIm5ldHdvcmtJZCI6MTAwfV0=",
    "total": 6.272,
    "userId": 139262667,
    "walletAddress": "0x1"
  }
}